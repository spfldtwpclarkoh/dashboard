<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Springfield Twp Road Work/Closures</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js for the interactive map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Leaflet Routing Machine for drawing routes -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .active-closure {
            background-color: #eef2ff;
            border-color: #4f46e5;
            transform: scale(1.02);
        }
        .leaflet-control-container {
            z-index: 20 !important;
        }
        /* Hide the default routing itinerary panel */
        .leaflet-routing-container {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 overflow-hidden">

    <div id="map" class="absolute top-0 left-0 w-screen h-screen z-0"></div>

    <div class="absolute top-4 left-4 z-10 w-full max-w-sm md:max-w-md bg-white/90 backdrop-blur-sm rounded-2xl shadow-xl flex flex-col max-h-[calc(100vh-2rem)]">
        
        <header class="p-4 text-center border-b border-gray-200 shrink-0">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-900">Road Work & Closures</h1>
        </header>

        <div id="closures-list-container" class="overflow-y-auto p-2">
            <div id="closures-list" class="space-y-3">
                 <div id="loading-state" class="text-center p-8">
                    <div class="flex justify-center items-center space-x-2">
                        <svg class="animate-spin h-5 w-5 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <p class="text-gray-500">Loading and processing locations...</p>
                    </div>
                </div>
                <div id="error-state" class="hidden text-center p-8 bg-red-50 border border-red-200 rounded-lg">
                    <p class="text-red-700 font-medium">Could not fetch data.</p>
                    <p class="text-red-600 text-sm mt-1">Please ensure the Google Sheet URL is correct and published.</p>
                </div>
            </div>
        </div>
    </div>

    <footer class="absolute bottom-2 left-4 z-10 text-xs text-gray-700 bg-white/60 backdrop-blur-sm px-2 py-1 rounded-md shadow">
        <p>&copy; 2025 TFRANK615</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION ---
            const googleSheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSgaVOwKFXoya_LyGOX5_CGFkWKw56X6huBFo_t84Sc_UEByoyHdhb3RcfLcIyWHYAlLXdRGNRrf_1B/pub?gid=1376438438&single=true&output=csv';

            // --- MAP INITIALIZATION ---
            const map = L.map('map', { 
                zoomControl: false
            }).setView([39.92106293890123, -83.80722068555369], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // --- ZONING DATA ---
            function addZoningLayer() {
                 fetch('./spfldTownshipBound.geojson') // Changed file name
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok for GeoJSON file.');
                        }
                        return response.json();
                    })
                    .then(zoningData => {
                        // Load all features from the new file, assuming it only contains the desired boundary
                        const boundaryFeatures = zoningData.features;

                        const boundaryGeoJSON = {
                            "type": "FeatureCollection",
                            "features": boundaryFeatures
                        };

                        const townshipStyle = {
                            "color": "#1e40af",
                            "weight": 2,
                            "opacity": 0.65,
                            "fillColor": "#60a5fa",
                            "fillOpacity": 0.15
                        };

                        L.geoJSON(boundaryGeoJSON, {
                            style: townshipStyle
                        }).addTo(map);
                    })
                    .catch(error => {
                        console.error('Error loading or parsing zoning GeoJSON:', error);
                    });
            }

            const closuresList = document.getElementById('closures-list');
            const loadingState = document.getElementById('loading-state');
            const errorState = document.getElementById('error-state');
            
            let markers = {};

            function getCoordsForMileMarker(mile) {
                const clarkCountyStart = { mm: 41, lat: 39.855, lng: -84.03 };
                const clarkCountyEnd = { mm: 67, lat: 39.905, lng: -83.55 };

                if (mile < clarkCountyStart.mm || mile > clarkCountyEnd.mm) {
                    console.warn(`Mile marker ${mile} is outside the bounds of Clark County (approx. 41-67).`);
                    return null;
                }

                const totalMiles = clarkCountyEnd.mm - clarkCountyStart.mm;
                const targetFraction = (mile - clarkCountyStart.mm) / totalMiles;
                const lat = clarkCountyStart.lat + targetFraction * (clarkCountyEnd.lat - clarkCountyStart.lat);
                const lng = clarkCountyStart.lng + targetFraction * (clarkCountyEnd.lng - clarkCountyStart.lng);
                return { lat, lng };
            }

            async function parseLocation(locationString) {
                if (!locationString) return null;
                
                const mileMarkerRegex = /I-?70\s+(?:MM|Mile\sMarker)\s+(\d+(\.\d+)?)/i;
                const mileMatch = locationString.match(mileMarkerRegex);
                if (mileMatch) {
                    const mileNumber = parseFloat(mileMatch[1]);
                    const coords = getCoordsForMileMarker(mileNumber);
                    if (coords) {
                        return { coords, isIntersection: false, displayName: `I-70 Mile Marker ${mileNumber}` };
                    }
                }

                const coordRegex = /^\s*(-?\d{1,3}(?:\.\d+)?)\s*,\s*(-?\d{1,3}(?:\.\d+)?)\s*$/;
                const coordMatch = locationString.match(coordRegex);
                if (coordMatch) {
                    const lat = parseFloat(coordMatch[1]);
                    const lng = parseFloat(coordMatch[2]);
                    if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        return { coords: { lat, lng }, isIntersection: false, displayName: `[Pinned Location]` };
                    }
                }

                const geocodeResult = await geocodeAddress(locationString);
                if (geocodeResult) {
                    const displayName = geocodeResult.isIntersection 
                        ? locationString.replace(/\s+(?:and|&|@)\s+|\s*\/\s*/i, ' & ') 
                        : locationString;
                    return { coords: { lat: geocodeResult.lat, lng: geocodeResult.lng }, isIntersection: geocodeResult.isIntersection, displayName };
                }
                
                console.warn(`Could not parse or geocode the location: "${locationString}"`);
                return null;
            }

            async function geocodeAddress(address) {
                const intersectionSeparators = /\s+(?:and|&|@)\s+|\s*\/\s*/i;
                let formattedAddress = address;
                const isIntersection = intersectionSeparators.test(address);

                if (isIntersection) {
                    const parts = address.split(intersectionSeparators);
                    if (parts.length > 1) {
                        // Updated location context for geocoding
                        const locationContext = "Springfield Township, Clark County, OH";
                        if (!parts[1].toLowerCase().includes('ohio') && !parts[1].toLowerCase().includes('oh') && !parts[1].toLowerCase().includes('clark county')) {
                            formattedAddress = `${parts[0].trim()} and ${parts[1].trim()}, ${locationContext}`;
                        } else {
                            formattedAddress = `${parts[0].trim()} and ${parts[1].trim()}`;
                        }
                    }
                }

                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(formattedAddress)}`;
                try {
                    const response = await fetch(url, { headers: { 'Accept': 'application/json' }});
                    if (!response.ok) throw new Error('Geocoding response was not ok.');
                    const data = await response.json();
                    if (data && data.length > 0) {
                        return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon), isIntersection };
                    }
                    console.warn(`Could not geocode the address: "${formattedAddress}"`);
                    return null;
                } catch (error) {
                    console.error(`Geocoding failed for address "${address}":`, error);
                    return null;
                }
            }

            async function fetchAndDisplayClosures() {
                try {
                    const response = await fetch(googleSheetUrl);
                    if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                    const csvText = await response.text();
                    const closures = parseCSV(csvText);
                    await processClosures(closures);
                } catch (error) {
                    console.error('Failed to fetch road closures:', error);
                    loadingState.style.display = 'none';
                    errorState.style.display = 'block';
                }
            }

            function parseCSV(text) {
                const lines = text.split(/\r?\n/).filter(line => line.trim() !== '');
                if (lines.length < 2) return [];
                const headers = lines[0].split(',').map(h => h.trim());
                return lines.slice(1).map(line => {
                    const values = [];
                    let currentVal = '';
                    let inQuotes = false;
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"' && (!inQuotes || line[i+1] !== '"')) {
                            inQuotes = !inQuotes;
                        } else if (char === '"' && inQuotes && line[i+1] === '"') {
                            currentVal += '"';
                            i++;
                        } else if (char === ',' && !inQuotes) {
                            values.push(currentVal.trim());
                            currentVal = '';
                        } else {
                            currentVal += char;
                        }
                    }
                    values.push(currentVal.trim());
                    const entry = {};
                    headers.forEach((header, index) => {
                        entry[header] = values[index] || '';
                    });
                    return entry;
                });
            }

            async function processClosures(closures) {
                closuresList.innerHTML = '';
                
                const locationPromises = closures.map(async (closure, index) => {
                    if (!closure.Address) return null;
                    
                    const startLocation = await parseLocation(closure.Address);
                    let endLocation = null;

                    if (closure.EndAddress && closure.EndAddress.trim() !== '') {
                        endLocation = await parseLocation(closure.EndAddress);
                    }

                    if (startLocation) {
                         return { ...closure, startLocation, endLocation, originalIndex: index };
                    }
                    return null;
                });

                const geocodedClosures = (await Promise.all(locationPromises)).filter(Boolean);
                
                loadingState.style.display = 'none';

                if (geocodedClosures.length === 0) {
                    closuresList.innerHTML = '<p class="text-gray-500 text-center p-4">No Known Road Work or Closures at this time</p>';
                    return;
                }
                
                const pointIcon = L.divIcon({
                    html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#dc2626" width="32" height="32" style="filter: drop-shadow(0 2px 2px rgb(0 0 0 / 0.4));"><path fill-rule="evenodd" d="M11.54 22.351l.07.04.028.016a.76.76 0 00.723 0l.028-.015.071-.041a16.975 16.975 0 005.169-4.469 9.857 9.857 0 002.582-6.755A9.857 9.857 0 0012 2.25a9.857 9.857 0 00-9.857 9.857 9.857 9.857 0 002.582 6.755 16.975 16.975 0 005.169 4.469zM12 14.25a3.75 3.75 0 100-7.5 3.75 3.75 0 000 7.5z" clip-rule="evenodd" /></svg>`,
                    className: '', iconSize: [32, 32], iconAnchor: [16, 32], popupAnchor: [0, -32]
                });

                const allCoords = [];
                geocodedClosures.forEach((closure) => {
                    const statusColor = closure.Status?.toLowerCase() === 'active' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800';
                    const statusText = closure.Status || 'Planned';
                    const displayName = closure.RoadName || closure.startLocation.displayName;

                    // NEW LOGIC: Only create the 'Closure Between' paragraph if the data exists.
                    let closureBetweenHtml = '';
                    if (closure.ClosureBetween && closure.ClosureBetween.trim() !== '') {
                        closureBetweenHtml = `<p class="text-xs text-gray-500 mt-2"><strong class="text-gray-600">Closure between:</strong> ${closure.ClosureBetween}</p>`;
                    }
                    
                    const listItem = document.createElement('div');
                    listItem.className = 'p-3 border rounded-lg cursor-pointer hover:bg-gray-50 transition-all duration-200';
                    listItem.id = `closure-${closure.originalIndex}`;
                    listItem.innerHTML = `
                        <div class="flex justify-between items-start">
                            <h3 class="font-bold text-md text-indigo-700">${displayName}</h3>
                            <span class="text-xs font-semibold px-2 py-1 rounded-full ${statusColor}">${statusText}</span>
                        </div>
                        <p class="text-gray-600 mt-1 text-sm">${closure.Description || 'No description.'}</p>
                        ${closureBetweenHtml}
                        <p class="text-xs text-gray-500 mt-1"><strong class="text-gray-600">Duration:</strong> ${closure.StartDate || 'N/A'} to ${closure.EndDate || 'N/A'}</p>
                    `;
                    closuresList.appendChild(listItem);
                    
                    if (closure.endLocation && closure.startLocation) {
                        const startCoords = closure.startLocation.coords;
                        const endCoords = closure.endLocation.coords;
                        allCoords.push([startCoords.lat, startCoords.lng]);
                        allCoords.push([endCoords.lat, endCoords.lng]);
                        
                        L.Routing.control({
                            waypoints: [L.latLng(startCoords.lat, startCoords.lng), L.latLng(endCoords.lat, endCoords.lng)],
                            createMarker: () => null,
                            lineOptions: { styles: [{ color: '#b91c1c', opacity: 0.8, weight: 7 }] }
                        }).addTo(map);

                        const startMarker = L.marker([startCoords.lat, startCoords.lng], { icon: pointIcon }).addTo(map).bindPopup(`<b>Start: ${displayName}</b><br>${closure.Description}`);
                        const endMarker = L.marker([endCoords.lat, endCoords.lng], { icon: pointIcon }).addTo(map).bindPopup(`<b>End: ${displayName}</b><br>${closure.Description}`);
                        
                        listItem.addEventListener('click', () => {
                            const routeBounds = L.latLngBounds([startCoords, endCoords]);
                            map.flyToBounds(routeBounds.pad(0.3));
                            document.querySelectorAll('#closures-list > div').forEach(div => div.classList.remove('active-closure', 'border-indigo-400'));
                            listItem.classList.add('active-closure', 'border-indigo-400');
                        });

                    } else {
                        const { lat, lng } = closure.startLocation.coords;
                        allCoords.push([lat, lng]);

                        const markerOptions = closure.startLocation.isIntersection ? { icon: pointIcon } : {};
                        const marker = L.marker([lat, lng], markerOptions).addTo(map);

                        marker.bindPopup(`
                            <div style="font-family: Inter, sans-serif; max-width: 200px;">
                                <h4 style="font-weight: 700; font-size: 1rem; margin-bottom: 4px;">${displayName}</h4>
                                <p style="margin: 0; font-size: 0.875rem;">${closure.Description}</p>
                                <p style="font-size: 0.75rem; margin-top: 4px; color: #4b5563;"><strong>Status:</strong> ${statusText}</p>
                            </div>
                        `);
                        markers[closure.originalIndex] = marker;

                        listItem.addEventListener('click', () => {
                            map.flyTo([lat, lng], 16);
                            marker.openPopup();
                            document.querySelectorAll('#closures-list > div').forEach(div => div.classList.remove('active-closure', 'border-indigo-400'));
                            listItem.classList.add('active-closure', 'border-indigo-400');
                        });
                    }
                });

                if (allCoords.length > 0) {
                    const bounds = L.latLngBounds(allCoords);
                    map.fitBounds(bounds.pad(0.2));
                }
            }

            // --- INITIATE ---
            fetchAndDisplayClosures();
            addZoningLayer(); 
        });
    </script>

</body>
</html>

